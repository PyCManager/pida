<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>PIDA Service Authoring Guide</title><link rel="stylesheet" href="./docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.68.1" /><link rel="start" href="index.html" title="PIDA Developer Documentation" /><link rel="up" href="index.html" title="PIDA Developer Documentation" /><link rel="prev" href="index.html" title="PIDA Developer Documentation" /><link rel="next" href="ar01s03.html" title="Coding Style" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s03.html">Next</a></td></tr></table><hr /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2511308"></a>PIDA Service Authoring Guide</h2></div></div></div><p>PIDA has a very general concept of services (you might call them plugins in
another application). In general, a service is able to define any PIDA
function, that is anything PIDA can do, a service can do it too.</p><p>PIDA is essentially a bunch of services bound together by a <span class="strong"><strong>*Boss</strong></span>*. The
services are discovered from service directories and loaded by a <span class="strong"><strong>*Service
Manager</strong></span>* for the Boss.</p><p>To learn more about services, please investigate:</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2511342"></a>Service Overview</h3></div></div></div><p>A service is comprised of a directory on the file system. This directory is a
Python package with data.</p><p>The structure of this directory is like so for a service named "myservice":</p><pre class="screen">    myservice/
        __init__.py
        myservice.py
        service.pida
        test_myservice.py
        data/
        glade/
        pixmaps/
        uidef/
            myservice.xml</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2473501"></a>Individual Components</h3></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2473507"></a>myservice.py</h4></div></div></div><p>This is the file containing the Python code for the service. It is a Python
module and should contain an attribute <code class="literal">`Service</code>`, which is the Class which
will be instantiated as the service.</p><p>The service class has a number of class attributes which describe its
behaviour. These behaviours are:</p><div class="itemizedlist"><ul type="disc"><li>
Configuration
</li><li>
Commands
</li><li>
Events
</li><li>
Features
</li><li>
Actions
</li></ul></div><p><b>Configuration. </b>This is the global configuration options for the service.</p><p><b>Commands. </b>Commands are the external interface for the service. They can be called by any
other service, and this decoupling is cleaner than expecting, and calling an
actual method on a service.</p><p><b>Events. </b>Events are an asynchronous call back for the service. Any other service can
subscribe to an event explicitly, and by subscribing is notified when an event
occurs.</p><p><b>Features. </b>Features are behaviours that a service expects other services to provide for
it. If this makes no sense, imagine a situation in which a file-manager
service expects any service to subscribe to its right-click menu on a file. In
this way, the actions provided on that right-click menu are decentralized from
the menu itself, and can be provided anywhere. This is very similar to a
classical (e.g. Trac) <span class="strong"><strong>extension point</strong></span>.</p><p><b>Actions. </b>Actions are gtk.Actions and are used in the user interface. An action maps
directly to a single toolbar and menu action, and contains the necessary
information to create this user interface item from it, including label, stock
image etc.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472836"></a>Other files and directories</h4></div></div></div><p><b>__init__.py. </b>This file is required so that Python recognises the directory as a legitimate
Python package.</p><p><b>service.pida. </b>This empty file is just present to identify the package as a PIDA service.</p><p><b>data/. </b>This directory should contain any data files for the service that are not
included in the other resource directories.</p><p><b>glade/. </b>This directory contains the glade files for the service's views. Although
views can be created using Python-only, it is recommended for more detailed
plugin views that they use glade.</p><p><b>pixmaps/. </b>This directory should contain any custom pixmaps for the service. These can be
used in any way.</p><p><b>uidef/. </b>This directory should contain the UI Definition XML files for the service.
These are gtk.UIManager XML files, and define the menu bar and toolbar items
for the service. The file myservice.xml is automatically loaded by PIDA, but
others can exist in this directory and could be used to populate popup menus
or to be further merged with the standard UI defnition.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2472915"></a>Service Options</h3></div></div></div><p>Options are currently stored in the GConf database. They are registered at
activation time of the service. Each service has its own directory in the GConf
database at /apps/pida/service_name. On registering the options, if they do not
exist, they are set to the default value.</p><p>Service options are defined in the service's OptionsConifg. This class should be
the options_config attribute of the service class, and should subclass
pida.options.OptionsConfig.</p><p>The OptionsConfig has a method named create_options, which is called on service
activation. This method should contain the calls to create_option to create the
options. The signature for create_option is:</p><pre class="screen">create_option(name, label, type, default, documentation)</pre><p>For example:</p><pre class="screen">class MyServiceOptions(OptionsConfig):

    def create_options(self):
        self.create_option(
            'myoption',
            'myoption label',
            OTypeString,
            'default_value',
            'A string describing the option',
        )


class MyService(Service):

    options_config = MyServiceOptions</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2472975"></a>Service Commands</h3></div></div></div><p>Commands are the external interface for a service. This interface is
specifically provided to other services for use of service activities.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2472984"></a>Defining Commands</h4></div></div></div><p>Commands are defined as methods on the <code class="literal">commands_config</code> attribute of the
Service class. This attribute should reference a subclass of
<code class="literal">pida.core.commands.CommandsConfig</code> class. Any method defined on that class will
be available as a command on the service.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2473205"></a>Calling service commands</h4></div></div></div><p>Commands are called on a service using the <code class="literal">cmd</code> method of a service. Calling
commands on other services must be performed through the Boss' <code class="literal">cmd</code> method
which takes as an additional parameter then name of the target service.</p><p>For example, execute a shell from a service:</p><pre class="screen">self.boss.cmd(
    'commander',        <a id="CO1-1"></a><img src="./images/icons/callouts/1.png" alt="1" border="0" />
    'execute_shell',    <a id="CO1-2"></a><img src="./images/icons/callouts/2.png" alt="2" border="0" />
)</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><a href="#CO1-1"><img src="./images/icons/callouts/1.png" alt="1" border="0" /></a> </td><td valign="top" align="left">
The target service name
</td></tr><tr><td width="5%" valign="top" align="left"><a href="#CO1-2"><img src="./images/icons/callouts/2.png" alt="2" border="0" /></a> </td><td valign="top" align="left">
The target service command
</td></tr></table></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2473385"></a>Using arguments on service commands</h4></div></div></div><p>All arguments to service commands must be passed as keyword arguments. Because
of this, they can be passed in any order after the servicename, and commandname
parameters.</p><p>For example, execute a shell from a service starting in an explicit directory:</p><pre class="screen">self.boss.cmd(
    'commander',
    'execute_shell',
    cwd = '/',
)</pre></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
