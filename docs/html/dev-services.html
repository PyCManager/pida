<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>PIDA Service Authoring Guide</title><link rel="stylesheet" href="./docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.68.1" /></head><body><div class="article" lang="en" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="id2456407"></a>PIDA Service Authoring Guide</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Ali</span> <span class="surname">Afshar</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a href="mailto:aafshar@gmail.com">aafshar@gmail.com</a>&gt;</code></p></div></div></div></div></div><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id2495013">Service Overview</a></span></dt><dt><span class="section"><a href="#id2495043">Individual Components</a></span></dt><dd><dl><dt><span class="section"><a href="#id2495048">myservice.py</a></span></dt><dt><span class="section"><a href="#id2456595">Other files and directories</a></span></dt></dl></dd><dt><span class="section"><a href="#id2456674">Service Options</a></span></dt><dt><span class="section"><a href="#id2456735">Service Commands</a></span></dt><dd><dl><dt><span class="section"><a href="#id2456819">Defining Commands</a></span></dt><dt><span class="section"><a href="#id2456848">Calling service commands</a></span></dt><dt><span class="section"><a href="#id2457025">Using arguments on service commands</a></span></dt></dl></dd><dt><span class="section"><a href="#id2457055">Service Events</a></span></dt><dd><dl><dt><span class="section"><a href="#id2457070">Events definition</a></span></dt><dt><span class="section"><a href="#id2457464">Create your own new events</a></span></dt><dt><span class="section"><a href="#id2457507">Subscribe to other services' events</a></span></dt><dt><span class="section"><a href="#id2457603">Events emition</a></span></dt></dl></dd><dt><span class="section"><a href="#id2457659">Service Views</a></span></dt><dd><dl><dt><span class="section"><a href="#id2457673">Creating Views</a></span></dt><dt><span class="section"><a href="#id2457694">Glade3 Views</a></span></dt><dt><span class="section"><a href="#id2504480">Pure PyGTK Views</a></span></dt><dt><span class="section"><a href="#id2504517">Instantiating views</a></span></dt><dt><span class="section"><a href="#id2504539">Adding Views to PIDA</a></span></dt><dt><span class="section"><a href="#id2504689">View icons and labels</a></span></dt></dl></dd><dt><span class="section"><a href="#id2504733">Using custom pixmaps in services</a></span></dt><dt><span class="section"><a href="#id2504758">Links</a></span></dt></dl></div><p>PIDA has a very general concept of services (you might call them plugins in
another application). In general, a service is able to define any PIDA
function, that is anything PIDA can do, a service can do it too.</p><p>PIDA is essentially a bunch of services bound together by a <span class="strong"><strong>*Boss</strong></span>*. The
services are discovered from service directories and loaded by a <span class="strong"><strong>*Service
Manager</strong></span>* for the Boss.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2495013"></a>Service Overview</h2></div></div></div><p>A service is comprised of a directory on the file system. This directory is a
Python package with data.</p><p>The structure of this directory is like so for a service named "myservice":</p><pre class="screen">    myservice/
        __init__.py
        myservice.py
        service.pida
        test_myservice.py
        data/
        glade/
        pixmaps/
        uidef/
            myservice.xml</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2495043"></a>Individual Components</h2></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2495048"></a>myservice.py</h3></div></div></div><p>This is the file containing the Python code for the service. It is a Python
module and should contain an attribute <code class="literal">`Service</code>`, which is the Class which
will be instantiated as the service.</p><p>The service class has a number of class attributes which describe its
behaviour. These behaviours are:</p><div class="itemizedlist"><ul type="disc"><li>
Configuration
</li><li>
Commands
</li><li>
Events
</li><li>
Features
</li><li>
Actions
</li></ul></div><p><b>Configuration. </b>This is the global configuration options for the service.</p><p><b>Commands. </b>Commands are the external interface for the service. They can be called by any
other service, and this decoupling is cleaner than expecting, and calling an
actual method on a service.</p><p><b>Events. </b>Events are an asynchronous call back for the service. Any other service can
subscribe to an event explicitly, and by subscribing is notified when an event
occurs.</p><p><b>Features. </b>Features are behaviours that a service expects other services to provide for
it. If this makes no sense, imagine a situation in which a file-manager
service expects any service to subscribe to its right-click menu on a file. In
this way, the actions provided on that right-click menu are decentralized from
the menu itself, and can be provided anywhere. This is very similar to a
classical (e.g. Trac) <span class="strong"><strong>extension point</strong></span>.</p><p><b>Actions. </b>Actions are gtk.Actions and are used in the user interface. An action maps
directly to a single toolbar and menu action, and contains the necessary
information to create this user interface item from it, including label, stock
image etc.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2456595"></a>Other files and directories</h3></div></div></div><p><b>__init__.py. </b>This file is required so that Python recognises the directory as a legitimate
Python package.</p><p><b>service.pida. </b>This empty file is just present to identify the package as a PIDA service.</p><p><b>data/. </b>This directory should contain any data files for the service that are not
included in the other resource directories.</p><p><b>glade/. </b>This directory contains the glade files for the service's views. Although
views can be created using Python-only, it is recommended for more detailed
plugin views that they use glade.</p><p><b>pixmaps/. </b>This directory should contain any custom pixmaps for the service. These can be
used in any way.</p><p><b>uidef/. </b>This directory should contain the UI Definition XML files for the service.
These are gtk.UIManager XML files, and define the menu bar and toolbar items
for the service. The file myservice.xml is automatically loaded by PIDA, but
others can exist in this directory and could be used to populate popup menus
or to be further merged with the standard UI defnition.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2456674"></a>Service Options</h2></div></div></div><p>Options are currently stored in the GConf database. They are registered at
activation time of the service. Each service has its own directory in the GConf
database at /apps/pida/service_name. On registering the options, if they do not
exist, they are set to the default value.</p><p>Service options are defined in the service's OptionsConifg. This class should be
the options_config attribute of the service class, and should subclass
pida.options.OptionsConfig.</p><p>The OptionsConfig has a method named create_options, which is called on service
activation. This method should contain the calls to create_option to create the
options. The signature for create_option is:</p><pre class="screen">create_option(name, label, type, default, documentation)</pre><p>For example:</p><pre class="screen">class MyServiceOptions(OptionsConfig):

    def create_options(self):
        self.create_option(
            'myoption',
            'myoption label',
            OTypeString,
            'default_value',
            'A string describing the option',
        )


class MyService(Service):

    options_config = MyServiceOptions</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2456735"></a>Service Commands</h2></div></div></div><p>Commands are the external interface for a service. This interface is
specifically provided to other services for use of service activities.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2456819"></a>Defining Commands</h3></div></div></div><p>Commands are defined as methods on the <code class="literal">commands_config</code> attribute of the
Service class. This attribute should reference a subclass of
<code class="literal">pida.core.commands.CommandsConfig</code> class. Any method defined on that class will
be available as a command on the service.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2456848"></a>Calling service commands</h3></div></div></div><p>Commands are called on a service using the <code class="literal">cmd</code> method of a service. Calling
commands on other services must be performed through the Boss' <code class="literal">cmd</code> method
which takes as an additional parameter then name of the target service.</p><p>For example, execute a shell from a service:</p><pre class="screen">self.boss.cmd(
    'commander',        <a id="CO1-1"></a><img src="./images/icons/callouts/1.png" alt="1" border="0" />
    'execute_shell',    <a id="CO1-2"></a><img src="./images/icons/callouts/2.png" alt="2" border="0" />
)</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><a href="#CO1-1"><img src="./images/icons/callouts/1.png" alt="1" border="0" /></a> </td><td valign="top" align="left">
The target service name
</td></tr><tr><td width="5%" valign="top" align="left"><a href="#CO1-2"><img src="./images/icons/callouts/2.png" alt="2" border="0" /></a> </td><td valign="top" align="left">
The target service command
</td></tr></table></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2457025"></a>Using arguments on service commands</h3></div></div></div><p>All arguments to service commands must be passed as keyword arguments. Because
of this, they can be passed in any order after the servicename, and commandname
parameters.</p><p>For example, execute a shell from a service starting in an explicit directory:</p><pre class="screen">self.boss.cmd(
    'commander',
    'execute_shell',
    cwd = '/',
)</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2457055"></a>Service Events</h2></div></div></div><p>The events are asynchronous call back for the service. So any other service can
subscribe its call back to an event, and it will get called back once the event
occurs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2457070"></a>Events definition</h3></div></div></div><p>To create a new event, like earlier, you just need to create a new class
that you can call <span class="emphasis"><em>MyServiceEvents</em></span>, and you bind it to your <span class="emphasis"><em>MyService</em></span>
class doing <span class="emphasis"><em>events_config = MyServiceEvents</em></span>.</p><pre class="screen">class MyServiceEvents(EventsConfig):
    def create_events(self):
        [...]
    def subscribe_foreign_events(self):
        [...]

class MyService(Service):
    events_config = MyServiceEvents</pre><p>So in that example code, you can notice the two methods you need to implement
to manage your own events. You have to define in create_events all the events
your service is about to use, and in subscribe_foreign_events all the events
from other services your service needs.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2457464"></a>Create your own new events</h3></div></div></div><p>So, once you have your <span class="emphasis"><em>EventsConfig</em></span> ready, you need to implement the
create_events method so you can have your own new events. Three steps
are needed to create an event :</p><pre class="literallayout">(1) You call self.create_event() on the event name
(2) You subscribe a new callback to the event you just made
(3) You implement the new event's callback so it acts when it is emitted.</pre><pre class="screen">    def create_events(self):
        self.create_event('myevent')                     # (1)
        self.subscribe_event('myevent', self.on_myevent) # (2)
        self.create_event('my_foreign_event')

    def on_myevent(self,param=None):                     # (3)
        print 'myevent receipt'
        if param != None:
            print 'with param:', param</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2457507"></a>Subscribe to other services' events</h3></div></div></div><p>We have seen how we can bind callbacks to events you created in
your own service. But you often need to interact with other services
as well. To do so, you need to implement the subscribe_foreign_events()
method the following way :</p><pre class="screen">    def subscribe_foreign_events(self):
        self.subscribe_foreign_event('editor', 'started',
                                     self.on_editor_startup)</pre><p>for each event you want to bind a call back, you need to call the
subscribe_foreign_event() method. In the example above, when the editor
service launches the started event, self.on_editor_startup() gets called.</p><pre class="screen">self.subscribe_foreign_event('SERVICE_NAME', 'EVENT_NAME', CALLBACK_FUNCTION)</pre><p>where <span class="strong"><strong>SERVICE_NAME</strong></span> is the destination service, <span class="strong"><strong>EVENT_NAME</strong></span> the event to bind to,
<span class="strong"><strong>CALLBACK_FUNCTION</strong></span> the function to be called when the event is emitted.</p><p>Now suppose you want to give other services' programmers an event of your own
service. To do so, you need to call create_event() in create_events() with the
name of your event (ie see <span class="emphasis"><em>my_foreign_event</em></span> above).</p><p>Then in the foreign service, in the subscribe_foreign_events() method you just
need to subscribe to the event:</p><pre class="screen">    def subscribe_foreign_events(self):
        self.subscribe_foreign_event('myservice', 'my_foreign_event',
                                     self.on_myservice_foreign_event)</pre><p>and finally define your callback.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2457603"></a>Events emition</h3></div></div></div><p>Now you have defined and bound all your events in your service and all
you need is to emit them when you need them to be executed. Well, it's
fairly simple, just call the emit() method :</p><pre class="screen">    [...]
    self.emit('myevent')
    self.emit('myevent', param='hello world')
    self.emit('my_foreign_event')
    [...]
    self.get_service('myservice').emit('myevent')
    self.get_service('myservice').emit('myevent', param='hello from some other place')
    self.get_service('myservice').emit('my_foreign_event')
    [...]</pre><p>As you can see in the examples above, emit can be used in different contexts
and with or without parameters. As a rule, every event defined can be called
using the emit() method either from your own service (ie in <span class="emphasis"><em>MyService</em></span>) or
from someone else's service (then you use get_service().emit()).</p><p>If your callback function needs parameters, you need to give the options to
the emit method. You can also use, as in the above example, non-mandatory
parameters.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2457659"></a>Service Views</h2></div></div></div><p>Service views are almost anything that appears visually in PIDA (apart from the
main toolbar and menubar). All of these views belong to a service.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2457673"></a>Creating Views</h3></div></div></div><p>Views may be designed in Glade3, or in pure <a href="#PyGTK">[PyGTK]</a>. Each method of view
creation has its advantages and disadvantages, and these are discussed below.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2457694"></a>Glade3 Views</h3></div></div></div><p>Views created with Glade3 have the following advantages:</p><div class="itemizedlist"><ul type="disc"><li>
Better maintainability
</li><li>
Automatic signal callback connection
</li></ul></div><p>The glade-file itself should be places in the directory glade/ in the service
directory, and should be named appropriately so as not to conflict with any
other service glade file. The extension <code class="literal">.glade</code> is preferred. So, for example a
well named glade file is <code class="literal">project-properties-editor.glade</code>.</p><p>This glade file is used by subclassing <code class="literal">pida.ui.views.PidaGladeView</code> and setting
the gladefile attribute on the class, for example for the glade file above:</p><pre class="screen">from pida.ui.views import PidaGladeView

class ProjectPropertiesView(PidaGladeView):

    gladefile = 'project-properties-editor'</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./images/icons/note.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The glade file attribute omits the extension part of the file name.</p></td></tr></table></div><p>The glade-file should contain a single top-level container (usually a
<code class="literal">gtk.Window</code>), and this <span class="strong"><strong>must have the same name as the glade file (without
extension</strong></span>.</p><p>The widget inside this container will be taken out of the Window and
incorporated into Pida's view.</p><p>All widgets in the glade view, are attached to the view instances namespace, so
that they can be accessed from the instance, for example if there is a text entry called
<code class="literal">name_entry</code>, the attribute <code class="literal">self.name_entry</code> or <code class="literal">my_view.name_entry</code> would
reference that entry.</p><p>Signals of items in the glade view are automatically connected if you provide
the correct method on the glade view. These methods are named as
<code class="literal">on_&lt;widget_name&gt;__&lt;signal_name&gt;</code>. For example, if there is a button on the
view called <code class="literal">close_button</code>, and you wish to connect to it's <code class="literal">clicked</code> signal,
you would provide the following method in order to automatically connect the
signal for the widget:</p><pre class="screen">def on_close_button__clicked(self, button):
    print '%s was clicked!' % button</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2504480"></a>Pure PyGTK Views</h3></div></div></div><p>These views should subclass <code class="literal">pida.ui.views.PidaView</code> and should create the
necessary widgets by overriding the create_ui method. The widgets can be added
to the view by using the <code class="literal">view.add_main_widget(widget, expand=True, fill=True)</code>.
The widgets will be added to the top-level VBox in the view.</p><p>There is no signal autoconnection, and widgets behave exactly as if they had
been created with PyGTK in any other circumstance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2504517"></a>Instantiating views</h3></div></div></div><p>The service can instantiate its views at any time. They should pass the instance
of the service as the first parameter to the View constructor. The service will
then be stored as the <code class="literal">svc</code> attribute on the view.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2504539"></a>Adding Views to PIDA</h3></div></div></div><p>Views are displayed at runtime by calling the <span class="emphasis"><em>window</em></span> service's command
<span class="emphasis"><em>add_view</em></span>. The required paned must be passed as well as the view itself.</p><p>The paned attribute to the command should be one of:</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">Buffer</code>
</li><li>
<code class="literal">Plugin</code>
</li><li>
<code class="literal">Terminal</code>
</li></ul></div><p>The buffer paned is the left sidebar, the plugin paned is the right sidebar, and
the terminal paned is the bottom bar. In general the guidelines for which paned
to add views to are:</p><div class="itemizedlist"><ul type="disc"><li>
Permanent views should be added to the Buffer paned
</li><li>
Views relating to the current document should be added to the Buffer or
      Plugin paned
</li><li>
Configuration or property views should be added to the Plugin paned
</li><li>
Multiple view (eg terminal emulators, diffs, and web browsers), or those
      with a lot of data should be added to the Terminal paned.
</li></ul></div><p>An example of adding a view of type <code class="literal">MyServiceView</code> to the Terminal paned is as
follows:</p><pre class="screen"># Override the start method as a hook to when the service starts
def start(self):
    view = MyServiceView(self)
    self.boss.cmd('window', 'add_view', paned='Terminal', view=view)</pre><p>Numerous other examples are available in almost every service in <code class="literal">pida.services</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2504689"></a>View icons and labels</h3></div></div></div><p>View icons (the image displayed on the paned button) are referred to by their
stock ID, and set as a class attribute on the view <code class="literal">icon_name</code>. Similarly, the
text associating the icon is set as a class attribute on the view called
'label_text`.</p><p>Additionally, an <code class="literal">icon_name</code> and/or a <code class="literal">label_text</code> attribute can be passed to
the view constructor, and these will be displayed as the view's label and icon
when it is added to the PIDA main view.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2504733"></a>Using custom pixmaps in services</h2></div></div></div><p>Any pixmap placed in the pixmaps directory in the service (<code class="literal">myservice/pixmaps</code>)
will automatically be added as a stock image and can be used by the service
using its name (without extension) for View icons or for gtk.Buttons or
gtk.Images or any other widget which take a stock_id as an argument.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2504758"></a>Links</h2></div></div></div><div class="bibliomixed"><p class="bibliomixed">
<span class="bibliomisc">
<a id="PyGTK"></a>[PyGTK] <a href="http://pygtk.org" target="_top">PyGTK Website</a>
</span>
</p></div></div></div></body></html>
